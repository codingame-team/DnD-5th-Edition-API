import os
import re

from populate_functions import request_monster
from tools.download_tokens import download_image
from tools.parse_json_dungeon import parse_dungeon_json

from typing import List


def get_monster_counts(text):
    # pattern = r"(?:(\d+) x )?(\w+(?: \w+)*)"
    pattern = r"(?:(\d+) x )?([\w-]+(?: [\w-]+)*)"  # To include -

    # Split the text on "and"
    parts = text.split(';')[0]
    parts = parts.split(' and ') if 'and' in parts else [parts]

    monster_counts = {}
    for part in parts:
        match = re.match(pattern, part.strip())
        if match:
            count, monster = match.groups()
            count = int(count) if count else 1
            if monster in monster_counts:
                monster_counts[monster] += count
            else:
                monster_counts[monster] = count

    return monster_counts


def extract_hit_dice_and_damage(text):
    # Pattern to capture the hit value
    hit_pattern = r"\{@hit (\d+)\}"
    # Pattern to capture damage details
    damage_pattern = r"\{@h\}(\d+) \(\{@dice ([\d+dx\s\+\-]+)\}\) (\w+) damage|(\d+) \(\{@damage ([\d+dx\s\+\-]+)\}\) (\w+) damage"

    hit_match = re.search(hit_pattern, text)
    damage_matches = re.findall(damage_pattern, text)

    hit_dice_and_damage = {
        'hit': int(hit_match.group(1)) if hit_match else None,
        'damage': []
    }

    for match in damage_matches:
        # The regex produces two possible sets of matches
        total_damage1, dice1, damage_type1, total_damage2, dice2, damage_type2 = match

        if total_damage1:
            hit_dice_and_damage['damage'].append({
                'total_damage': int(total_damage1),
                'dice': dice1,
                'damage_type': damage_type1
            })
        elif total_damage2:
            hit_dice_and_damage['damage'].append({
                'total_damage': int(total_damage2),
                'dice': dice2,
                'damage_type': damage_type2
            })

    return hit_dice_and_damage


# if __name__ == '__main__':
#     text = "{@atk mw,rw} {@hit 5} to hit, reach 5 ft. or range 20/60 ft., one target. {@h}11 ({@dice 1d6 + 3} plus {@dice 1d8}) piercing damage, or 12 ({@damage 2d8 + 3}) piercing damage if used with two hands to make a melee attack."
#     text = "{@atk mw} {@hit 4} to hit, reach 5 ft., one target. {@h}5 ({@damage 1d6 + 2}) slashing damage."
#     result = extract_hit_dice_and_damage(text)
#     print(result)


if __name__ == '__main__':
    # text = '2 x Orc and 1 x Half-ogre'
    # text = "Ogre Bolt Launcher (cr 2, motm 200, mtf 220) and 2 x Ogre (cr 2, mm 237); deadly, 1350 xp, trying to lure the party into an ambush"
    # text = "Goblin (cr 1/4, mm 166); hard, 50 xp, consumed by disease and madness"
    # monsters = get_monster_counts(text)
    # print(monsters)

    bestiary: List[str] = []

    abs_path = os.path.abspath(os.path.dirname(__file__))
    abs_project_path = os.path.abspath(os.path.join(abs_path, os.pardir))
    dungeon_levels = [f for f in os.listdir(os.path.join(abs_project_path, 'maze')) if f.endswith(".json") and f.startswith("The")]
    for json_filename in dungeon_levels:
        # get dungeon structure
        pattern = r' \d+\.json'
        level: int = int(re.search(r'\d{2}', json_filename).group())
        level_fullname = re.sub(pattern, '', json_filename)
        # json_filename = 'dungeon.json' # generated by perl script (room+corridors without extras)
        dungeon = parse_dungeon_json(json_filename)

        # populate bestiary for this level

        # monsters located in rooms
        for i, room in enumerate(dungeon['rooms']):
            if room and 'contents' in room and 'inhabited' in room['contents']:
                monsters_tmp = get_monster_counts(text=room['contents']['inhabited'])
                # if 'Half' in monsters_tmp:
                #     print(room)
                for monster, count in monsters_tmp.items():
                    if monster in bestiary:
                        continue
                    bestiary.append(monster)

        # wandering monsters
        for i, wandering_monsters in dungeon['wandering_monsters'].items():
            monsters_tmp = get_monster_counts(text=wandering_monsters)
            # if 'Half' in monsters_tmp:
            #     print('Half keyword found!')
            for monster, count in monsters_tmp.items():
                if monster in bestiary:
                    continue
                # print(f'{level_fullname} L{level:02d} -> {monster}')
                bestiary.append(monster)

    print('#' * 50)

    # TODO Monsters
    todo_monsters: List[str] = []
    for monster_name in bestiary:
        try:
            monster_defined = request_monster(monster_name.lower().replace(' ', '-'))
        except FileNotFoundError:
            todo_monsters.append(monster_name)
    print(f'{len(todo_monsters)} todo monsters')
    print(('|'.join(todo_monsters)))
    for m in todo_monsters: print(m)

    print('#' * 50)

    # Download tokens for monster_kills.py
    print(f'{len(bestiary)} bestiary monsters')
    print(('|'.join(bestiary)))
    # Define the folder to save the image
    save_folder = "../images/monsters/tokens"
    mm_book_ref = "MM" # Monsters manual
    mpmm_book_ref = "MPMM" # Monsters of the Multiverse
    phb_book_ref = "PHB" # Player's Handbook
    vgm_book_ref = "VGM" # Volo's Guide to Monsters
    book_references = [mm_book_ref, mpmm_book_ref, phb_book_ref, vgm_book_ref]
    missing_monsters: List[str] = []
    for monster_name in bestiary:
        image_filename = os.path.join(save_folder, f"{monster_name}.webp")
        # Check if the image file already exists in the folder
        if not os.path.isfile(image_filename):
            missing_monsters += [monster_name]
            for book_ref in book_references:
                image_url = f"https://5e.tools/img/bestiary/tokens/{book_ref}/{monster_name}.webp"
                download_image(image_url, save_folder, monster_name)
                # Call the download_image function if the file doesn't exist
                http_status_code = download_image(image_url, save_folder, monster_name)
                if http_status_code == 200:
                    break
    print(f'{len(missing_monsters)} missing monsters')
    print(('|'.join(missing_monsters)))






